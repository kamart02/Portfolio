COPYRIGHT Uniwersytet Warszawski

Labirynt

NaleÅ¼y napisaÄ‡ program poszukujÄ…cy drogi w wielowymiarowym labiryncie.
Definicje

Labirynt jest zawarty w niepustym przedziale ğ‘˜
-wymiarowym (prostopadÅ‚oÅ›cianie ğ‘˜-wymiarowym) skÅ‚adajÄ…cym siÄ™ z ğ‘˜-wymiarowych kostek jednostkowych. KaÅ¼da z takich kostek moÅ¼e byÄ‡ wypeÅ‚niona, tworzÄ…c Å›ciany labiryntu, lub pusta, tworzÄ…c przestrzeÅ„, w ktÃ³rej moÅ¼na siÄ™ poruszaÄ‡. Po labiryncie moÅ¼na siÄ™ poruszaÄ‡, przechodzÄ…c pomiÄ™dzy pustymi kostkami stykajÄ…cymi siÄ™ Å›cianÄ… (ğ‘˜âˆ’1

)-wymiarowÄ….

PoÅ‚oÅ¼enie kaÅ¼dej kostki (pustej lub wypeÅ‚nionej) okreÅ›la siÄ™ przez podanie jej wspÃ³Å‚rzÄ™dnych, ktÃ³re sÄ… caÅ‚kowitymi liczbami dodatnimi.

Droga w labiryncie jest to ciÄ…g przejÅ›Ä‡ miÄ™dzy pustymi kostkami od pozycji poczÄ…tkowej do pozycji koÅ„cowej. Pozycje poczÄ…tkowÄ… i koÅ„cowÄ… definiuje siÄ™ przez podanie wspÃ³Å‚rzÄ™dnych dwÃ³ch pustych kostek. DÅ‚ugoÅ›Ä‡ drogi jest to liczba przejÅ›Ä‡. JeÅ›li pozycja koÅ„cowa jest jednoczeÅ›nie pozycjÄ… poczÄ…tkowÄ…, to droga ma dÅ‚ugoÅ›Ä‡ zero.
Dane wejÅ›ciowe

Program czyta dane ze standardowego wejÅ›cia. Poprawne dane skÅ‚adajÄ… siÄ™ z czterech linii tekstu. Trzy poczÄ…tkowe linie zawierajÄ… po ğ‘˜
liczb caÅ‚kowitych z przedziaÅ‚u od 1 do SIZE_MAX, gdzie ğ‘˜

jest dodatniÄ… liczbÄ… caÅ‚kowitÄ… okreÅ›lajÄ…cÄ… wymiar labiryntu. SÄ… to odpowiednio:

    ğ‘›1, ğ‘›2, ğ‘›3, â€¦, ğ‘›ğ‘˜
,
ğ‘¥1, ğ‘¥2, ğ‘¥3, â€¦, ğ‘¥ğ‘˜
,
ğ‘¦1, ğ‘¦2, ğ‘¦3, â€¦, ğ‘¦ğ‘˜

    ,

gdzie liczby ğ‘›ğ‘–
okreÅ›lajÄ… rozmiary labiryntu w poszczegÃ³lnych wymiarach, a liczby ğ‘¥ğ‘– i ğ‘¦ğ‘–

okreÅ›lajÄ… odpowiednio wspÃ³Å‚rzÄ™dne pozycji poczÄ…tkowej i koÅ„cowej.

Czwarta linia zawiera liczbÄ™ caÅ‚kowitÄ… opisujÄ…cÄ… poÅ‚oÅ¼enia Å›cian labiryntu. W rozwiniÄ™ciu dwÃ³jkowym tej liczby bit (ğ‘§1âˆ’1)+(ğ‘§2âˆ’1)ğ‘›1+(ğ‘§3âˆ’1)ğ‘›1ğ‘›2+â€¦+(ğ‘§ğ‘˜âˆ’1)ğ‘›1ğ‘›2â€¦ğ‘›ğ‘˜âˆ’1
okreÅ›la kostkÄ™ o wspÃ³Å‚rzÄ™dnych (ğ‘§1,ğ‘§2,ğ‘§3,â€¦,ğ‘§ğ‘˜)

. JeÅ›li bit ten ma wartoÅ›Ä‡ 0, to kostka jest pusta, a jeÅ›li ma wartoÅ›Ä‡ 1, to kostka jest wypeÅ‚niona.

Liczba w czwartej linii moÅ¼e byÄ‡ podana na dwa sposoby:

    liczba szesnastkowa zaczynajÄ…ca siÄ™ kombinacjÄ… znakÃ³w 0x, zapisana z uÅ¼yciem cyfr 0, 1, â€¦, 9, a, b, â€¦, f, A, B, â€¦ F.
    znak R, po ktÃ³rym wystÄ™puje piÄ™Ä‡ zapisanych przy podstawie 10 liczb caÅ‚kowitych z przedziaÅ‚u od 0 do UINT32_MAX: ğ‘

, ğ‘, ğ‘š, ğ‘Ÿ, ğ‘ 0, uÅ¼ywanych w niÅ¼ej opisany sposÃ³b, przy czym nakÅ‚adamy dodatkowy warunek, Å¼e liczba ğ‘š

    nie jest zerem.

Wyliczamy liczby ğ‘ 1
, ğ‘ 2, ğ‘ 3, â€¦, ğ‘ ğ‘Ÿ ze wzoru ğ‘ ğ‘–=(ğ‘ğ‘ ğ‘–âˆ’1+ğ‘)modğ‘š. Wyliczamy reszty ğ‘¤ğ‘–=ğ‘ ğ‘–modğ‘›1ğ‘›2â€¦ğ‘›ğ‘˜. Liczba opisujÄ…ca poÅ‚oÅ¼enie Å›cian labiryntu ma w rozwiniÄ™ciu dwÃ³jkowym ustawiony bit numer ğ‘—, jeÅ›li istnieje taki indeks ğ‘–, Å¼e ğ‘—mod232=ğ‘¤ğ‘–

.

Liczby mogÄ… byÄ‡ poprzedzone wiodÄ…cymi zerami. Liczby wystÄ™pujÄ…ce w jednej linii rozdzielone sÄ… dowolnÄ… liczbÄ… biaÅ‚ych znakÃ³w. MiÄ™dzy znakiem R a pierwszÄ… liczbÄ… moÅ¼e nie byÄ‡ odstÄ™pu lub moÅ¼e byÄ‡ dowolna liczba biaÅ‚ych znakÃ³w. Na poczÄ…tku i na koÅ„cu kaÅ¼dej linii moÅ¼e wystÄ™powaÄ‡ dowolna liczba biaÅ‚ych znakÃ³w.
Opis dziaÅ‚ania programu

Program czyta dane, a nastÄ™pnie, jeÅ›li sÄ… poprawne, wyznacza dÅ‚ugoÅ›Ä‡ najkrÃ³tszej drogi od pozycji poczÄ…tkowej do pozycji koÅ„cowej. Program wypisuje na standardowe wyjÅ›cie jednÄ… liniÄ™ (zakoÅ„czonÄ… znakiem przejÅ›cia do nowej linii, czyli w jÄ™zyku C znakiem \n o kodzie ASCII 10) zawierajÄ…cÄ… dÅ‚ugoÅ›Ä‡ znalezionej drogi (bez zer wiodÄ…cych) lub komunikat NO WAY, jeÅ›li nie ma drogi. Program koÅ„czy dziaÅ‚anie kodem 0. Program powinien jawnie zwolniÄ‡ zaalokowanÄ… pamiÄ™Ä‡.
ObsÅ‚uga bÅ‚Ä™dÃ³w

JeÅ›li dane wejÅ›ciowe sÄ… niepoprawne, to program wypisuje na standardowe wyjÅ›cie diagnostyczne jednÄ… liniÄ™ (zakoÅ„czonÄ… znakiem przejÅ›cia do nowej linii) zawierajÄ…cÄ… komunikat ERROR L, gdzie L jest liczbÄ… caÅ‚kowitÄ… z przedziaÅ‚u od 1 do 5. Jest to numer pierwszej linii zwiÄ…zanej z bÅ‚Ä™dem. JeÅ›li wystÄ…piÅ‚ nienaprawialny bÅ‚Ä…d, np. funkcja biblioteczna zakoÅ„czyÅ‚a siÄ™ niepowodzeniem, zabrakÅ‚o pamiÄ™ci, nie da siÄ™ wyznaczyÄ‡ wyniku, to program wypisuje na standardowe wyjÅ›cie diagnostyczne jednÄ… liniÄ™ (zakoÅ„czonÄ… znakiem przejÅ›cia do nowej linii) zawierajÄ…cÄ… komunikat ERROR 0. Program koÅ„czy dziaÅ‚anie kodem 1. Program przed zakoÅ„czeniem powinien jawnie zwolniÄ‡ zaalokowanÄ… pamiÄ™Ä‡, chyba Å¼e wystÄ…piÅ‚ bÅ‚Ä…d alokacji pamiÄ™ci.
PrzykÅ‚adowe dane

PrzykÅ‚adowe dane dla programu i wyniki jego dziaÅ‚ania znajdujÄ… siÄ™ w zaÅ‚Ä…czonym archiwum usage_examples.zip. SÄ… tam nastÄ™pujÄ…ce przykÅ‚ady:

    example1 â€“ maÅ‚y labirynt dwuwymiarowy z drogÄ… o dÅ‚ugoÅ›ci 12,
    example2 â€“ maÅ‚y labirynt jednowymiarowy z drogÄ… o dÅ‚ugoÅ›ci 5,
    example3 â€“ maÅ‚y labirynt trÃ³jwymiarowy, ale jeden wymiar jest zdegenerowany, pozycja koÅ„cowa jest pozycjÄ… poczÄ…tkowÄ…,
    example4 â€“ maÅ‚y labirynt trÃ³jwymiarowy z drogÄ… o dÅ‚ugoÅ›ci 4,
    example5 â€“ duÅ¼y labirynt jednowymiarowy bez drogi,
    error00 â€“ ewidentnie za duÅ¼y labirynt,
    error10 â€“ rozmiar labiryntu nie moÅ¼e byÄ‡ zerowy,
    error26 â€“ pozycja (poczÄ…tkowa) musi byÄ‡ w pustej kostce,
    error30 â€“ wspÃ³Å‚rzÄ™dne pozycji (koÅ„cowej) muszÄ… byÄ‡ dodatnie,
    error40 â€“ liczba opisujÄ…ca poÅ‚oÅ¼enie Å›cian ma za duÅ¼o bitÃ³w,
    error50 â€“ dane wejÅ›ciowe majÄ… za duÅ¼o linii.

Makefile

CzÄ™Å›ciÄ… zadania jest napisanie pliku makefile lub Makefile. W wyniku wywoÅ‚ania polecenia make powinien powstaÄ‡ program wykonywalny labyrinth. JeÅ›li ktÃ³ryÅ› z plikÃ³w ÅºrÃ³dÅ‚owych ulegnie zmianie, ponowne wpisanie make powinno na nowo stworzyÄ‡ plik wykonywalny. Plik makefile lub Makefile powinien dziaÅ‚aÄ‡ w nastÄ™pujÄ…cy sposÃ³b:

    osobno kompiluje kaÅ¼dy plik .c,
    linkuje wszystkie pliki .o,
    przy zmianie w pliku .c lub .h wykonuje tylko niezbÄ™dne akcje,
    wywoÅ‚anie make clean usuwa plik wykonywalny i dodatkowe pliki powstaÅ‚e podczas kompilowania.

Zalecamy kompilowanie programem gcc z opcjami:

-Wall -Wextra -Wno-implicit-fallthrough -std=c17 -O2

Skrypt testujÄ…cy

OsobnÄ… czÄ™Å›ciÄ… zadania jest napisanie skryptu test.sh. Po wywoÅ‚aniu

./test.sh prog dir

skrypt powinien uruchomiÄ‡ program prog dla wszystkich plikÃ³w wejÅ›ciowych postaci dir/*.in, porÃ³wnaÄ‡ wyniki z odpowiadajÄ…cymi im plikami dir/*.out i dir/*.err, a nastÄ™pnie wypisaÄ‡, ktÃ³re testy zakoÅ„czyÅ‚y siÄ™ powodzeniem, a ktÃ³re niepowodzeniem. Skrypt powinien akceptowaÄ‡ parametry z dowolnÄ… Å›cieÅ¼kÄ…, jakÄ… akceptuje powÅ‚oka.

Do wykrywania problemÃ³w z zarzÄ…dzaniem pamiÄ™ciÄ… naleÅ¼y uÅ¼yÄ‡ programu valgrind.
PozostaÅ‚e wymagania

RozwiÄ…zanie zadania powinno byÄ‡ napisane w jÄ™zyku C i korzystaÄ‡ z dynamicznie alokowanych struktur danych. Implementacja powinna byÄ‡ jak najefektywniejsza. NaleÅ¼y unikaÄ‡ zbÄ™dnego alokowania pamiÄ™ci i kopiowania danych.

Nie naleÅ¼y wprowadzaÄ‡ sztucznych ograniczeÅ„. WielkoÅ›Ä‡ danych i rozmiar labiryntu sÄ… ograniczone jedynie przez rozmiar dostÄ™pnej pamiÄ™ci i zakres arytmetyki komputera (64 bity).

Program bÄ™dzie sprawdzany na maszynie students.mimuw.edu.pl i musi kompilowaÄ‡ siÄ™ oraz dziaÅ‚aÄ‡ na tej maszynie.

Kod programu powinien byÄ‡ podzielony na moduÅ‚y.

ModuÅ‚ zwykle skÅ‚ada siÄ™ z dwÃ³ch plikÃ³w, np. x.c i x.h, gdzie x jest nazwÄ… moduÅ‚u, implementowanej przez ten moduÅ‚ struktury danych lub tp. Plik nagÅ‚Ã³wkowy x.h zawiera deklaracje operacji, struktur udostÄ™pnianych przez moduÅ‚ x, a plik x.c â€“ ich implementacjÄ™. W pliku nagÅ‚Ã³wkowym naleÅ¼y umieszczaÄ‡ jedynie deklaracje i definicje, ktÃ³re sÄ… czÄ™Å›ciÄ… interfejsu tego moduÅ‚u. Wszystkie szczegÃ³Å‚y powinny byÄ‡ ukryte w pliku z implementacjÄ….

ModuÅ‚ moÅ¼e teÅ¼ skÅ‚adaÄ‡ siÄ™ z samego pliku nagÅ‚Ã³wkowego, jeÅ›li udostÄ™pnia jedynie definicje staÅ‚ych bÄ…dÅº typÃ³w, lub funkcji, ktÃ³re sugerujemy kompilatorowi do rozwijania w miejscu wywoÅ‚ania (static inline).

ModuÅ‚ moÅ¼e teÅ¼ skÅ‚adaÄ‡ siÄ™ z samego pliku z implementacjÄ…, jeÅ›li nie udostÄ™pnia Å¼adnego interfejsu â€“ Å¼adne funkcje z tego moduÅ‚u nie sÄ… wywoÅ‚ywane z innych moduÅ‚Ã³w.

Ponadto rozwiÄ…zanie powinno zawieraÄ‡ pliki:

    makefile lub Makefile â€“ Patrz punkt â€Makefileâ€,
    test.sh â€“ Patrz punkt â€Skrypt testujÄ…cyâ€.

RozwiÄ…zanie naleÅ¼y oddaÄ‡ jako archiwum skompresowane programem zip lub parÄ… programÃ³w tar i gzip.
WskazÃ³wki

Warto zapoznaÄ‡ siÄ™ z typami i staÅ‚ymi zdefiniowanymi w plikach stdbool.h, stddef.h, stdint.h, inttypes.h, limits.h.

InspiracjÄ… moÅ¼e byÄ‡ algorytm two bit breadth first search stosowany do przeszukiwania duÅ¼ych grafÃ³w, patrz S. Edelkamp, S. SchrÃ¶dl, Heuristic Search: Theory and Applications, str. 271â€“273.
Punktacja

Za w peÅ‚ni poprawne rozwiÄ…zanie zadania implementujÄ…ce wszystkie funkcjonalnoÅ›ci moÅ¼na zdobyÄ‡ maksymalnie 20 punktÃ³w. RozwiÄ…zanie niekompilujÄ…ce siÄ™ bÄ™dzie ocenione na 0 punktÃ³w. Punkty bÄ™dÄ… odejmowane za poniÅ¼sze uchybienia:

    Za kaÅ¼dy test, ktÃ³rego program nie przejdzie, traci siÄ™ od 0,1 do 1 punktu.
    Za problemy z zarzÄ…dzaniem pamiÄ™ciÄ… moÅ¼na straciÄ‡ do 6 punktÃ³w.
    Za niezgodnÄ… ze specyfikacjÄ… strukturÄ™ plikÃ³w lub niezgodne ze specyfikacjÄ… nazwy plikÃ³w moÅ¼na straciÄ‡ do 4 punktÃ³w.
    Za zÅ‚Ä… jakoÅ›Ä‡ kodu, brzydki styl kodowania moÅ¼na straciÄ‡ do 4 punktÃ³w.
    Za ostrzeÅ¼enia wypisywane przez kompilator moÅ¼na straciÄ‡ do 2 punktÃ³w.
    Za brak lub Åºle dziaÅ‚ajÄ…cy makefile/Makefile moÅ¼na straciÄ‡ do 2 punktÃ³w.
    Za brak skryptu testujÄ…cego lub bÅ‚Ä™dy w tym skrypcie moÅ¼na straciÄ‡ do 3 punktÃ³w.
